<?xml version="1.0" encoding="UTF-8" ?>

<config>

	<luceneMatchVersion>4.10.1</luceneMatchVersion>
	<dataDir>${solr.data.dir:}</dataDir>
	<directoryFactory name="DirectoryFactory"
		class="${solr.directoryFactory:solr.NRTCachingDirectoryFactory}" />
	<codecFactory class="solr.SchemaCodecFactory" />

	<schemaFactory class="ClassicIndexSchemaFactory" />

	<indexConfig>
		<lockType>${solr.lock.type:native}</lockType>
		<infoStream>true</infoStream>
	</indexConfig>

	<jmx />

	<updateHandler class="solr.DirectUpdateHandler2">
		<updateLog>
			<str name="dir">${solr.ulog.dir:}</str>
		</updateLog>

		<autoCommit>
			<maxTime>${solr.autoCommit.maxTime:15000}</maxTime>
			<openSearcher>false</openSearcher>
		</autoCommit>


		<autoSoftCommit>
			<maxTime>${solr.autoSoftCommit.maxTime:-1}</maxTime>
		</autoSoftCommit>
	</updateHandler>



	<query>
		<maxBooleanClauses>1024</maxBooleanClauses>
		<filterCache class="solr.FastLRUCache" size="512"
			initialSize="512" autowarmCount="0" />

		<queryResultCache class="solr.LRUCache" size="512"
			initialSize="512" autowarmCount="0" />

		<documentCache class="solr.LRUCache" size="512"
			initialSize="512" autowarmCount="0" />
		<enableLazyFieldLoading>true</enableLazyFieldLoading>
		<queryResultWindowSize>20</queryResultWindowSize>
		<queryResultMaxDocsCached>200</queryResultMaxDocsCached>

		<listener event="newSearcher" class="solr.QuerySenderListener">
			<arr name="queries">
				<!-- <lst><str name="q">solr</str><str name="sort">price asc</str></lst> 
					<lst><str name="q">rocks</str><str name="sort">weight asc</str></lst> -->
			</arr>
		</listener>
		<listener event="firstSearcher" class="solr.QuerySenderListener">
			<arr name="queries">
				<lst>
					<str name="q">static firstSearcher warming in solrconfig.xml</str>
				</lst>
			</arr>
		</listener>
		<useColdSearcher>false</useColdSearcher>
		<maxWarmingSearchers>2</maxWarmingSearchers>

	</query>


	<requestDispatcher handleSelect="false">
		<requestParsers enableRemoteStreaming="true"
			multipartUploadLimitInKB="2048000" formdataUploadLimitInKB="2048"
			addHttpRequestToContext="false" />

		
		<httpCaching never304="true" />
	</requestDispatcher>


	<requestHandler name="/browse" class="solr.SearchHandler">
		<lst name="defaults">
			<str name="defType">edismax</str>
			<str name="wt">json</str>
			<str name="indent">true</str>
			<int name="rows">100</int>
			<str name="df">titre famille categorie</str>
			
			<str name="facet">on</str>
		
		</lst>
	</requestHandler>
	
	<requestHandler name="/select" class="solr.SearchHandler">
     <lst name="defaults">
		<str name="defType">edismax</str>
		<str name="wt">json</str>
        <str name="indent">true</str>
        <int name="rows">100</int>
	    <str name="qf">theme themeRech</str>
     </lst>
    </requestHandler>
    
    <requestHandler name="/nomenclature" class="solr.SearchHandler">
     <lst name="defaults">
		<str name="defType">edismax</str>
		<str name="wt">json</str>
        <str name="indent">true</str>
        <int name="rows">10</int>
        <str name="fl">
        	nomenclature_niveau 
        	nomenclature_code 
        	nomenclature_libelle
        	nomenclature_enfants
        	nomenclature_parents
        	naf2008_comprend
        	naf2008_neComprendPas
        	naf2008_noteGenerale
        </str>
	    <str name="qf">
	    	nomenclature_niveau 
	    	nomenclature_codeDotSplited 
	    	nomenclature_codeUndotted 
	    	nomenclature_libelle_recherche
	    </str>
     </lst>
    </requestHandler>
	
	<!-- Search Handler spécialisé pour les définitions RMES -->
    <requestHandler name="/definition" class="solr.SearchHandler">
        <lst name="defaults">
            <str name="defType">edismax</str>
            <str name="wt">json</str>
            <str name="indent">true</str>
            <str name="qf">titre titreEnfants</str>
            <str name="fq">type:"définition"</str>
            <str name="fq">sansParent:"true"</str>
            <str name="rows">2000</str>
        </lst>
    </requestHandler>

	<requestHandler name="/update" class="solr.UpdateRequestHandler" />

	<requestHandler name="/analysis/field" startup="lazy"
		class="solr.FieldAnalysisRequestHandler" />

	<requestHandler name="/analysis/document"
		class="solr.DocumentAnalysisRequestHandler" startup="lazy" />

	<!-- ping/healthcheck -->
	<requestHandler name="/admin/ping" class="solr.PingRequestHandler">
		<lst name="invariants">
			<str name="q">solrpingquery</str>
		</lst>
		<lst name="defaults">
			<str name="echoParams">all</str>
		</lst>
		<!-- An optional feature of the PingRequestHandler is to configure the 
			handler with a "healthcheckFile" which can be used to enable/disable the 
			PingRequestHandler. relative paths are resolved against the data dir -->
		<!-- <str name="healthcheckFile">server-enabled.txt</str> -->
	</requestHandler>

	<!-- Echo the request contents back to the client -->
	<requestHandler name="/debug/dump" class="solr.DumpRequestHandler">
		<lst name="defaults">
			<str name="echoParams">explicit</str>
			<str name="echoHandler">true</str>
		</lst>
	</requestHandler>

	<!-- Solr Replication The SolrReplicationHandler supports replicating indexes 
		from a "master" used for indexing and "slaves" used for queries. http://wiki.apache.org/solr/SolrReplication 
		It is also necessary for SolrCloud to function (in Cloud mode, the replication 
		handler is used to bulk transfer segments when nodes are added or need to 
		recover). https://wiki.apache.org/solr/SolrCloud/ -->
	<requestHandler name="/replication" class="solr.ReplicationHandler">
		<!-- To enable simple master/slave replication, uncomment one of the sections 
			below, depending on whether this solr instance should be the "master" or 
			a "slave". If this instance is a "slave" you will also need to fill in the 
			masterUrl to point to a real machine. -->
		<!-- <lst name="master"> <str name="replicateAfter">commit</str> <str name="replicateAfter">startup</str> 
			<str name="confFiles">schema.xml,stopwords.txt</str> </lst> -->
		<!-- <lst name="slave"> <str name="masterUrl">http://your-master-hostname:8983/solr</str> 
			<str name="pollInterval">00:00:60</str> </lst> -->
	</requestHandler>




	<searchComponent class="solr.MoreLikeThisComponent"
		name="mlt">
		<lst name="defaults">
			<str name="mlt.fl">titre libGeo_suggest_edge</str>
			<str name="mlt.qf">title^10.0 libGeo_suggest_edge^10.0</str>
		</lst>
	</searchComponent>



	<!-- Spell Check The spell check component can return a list of alternative 
		spelling suggestions. http://wiki.apache.org/solr/SpellCheckComponent -->
	<searchComponent name="spellcheck" class="solr.SpellCheckComponent">

		<str name="queryAnalyzerFieldType">texte_correction</str>

		<!-- Multiple "Spell Checkers" can be declared and used by this component -->

		<!-- a spellchecker built from a field of the main index -->
		<lst name="spellchecker">
			<str name="name">default</str>
			<str name="field">texte_correction</str>
			<str name="classname">solr.DirectSolrSpellChecker</str>
			<!-- the spellcheck distance measure used, the default is the internal 
				levenshtein -->
			<str name="distanceMeasure">internal</str>
			<!-- minimum accuracy needed to be considered a valid spellcheck suggestion -->
			<float name="accuracy">0.3</float>
			<!-- the maximum #edits we consider when enumerating terms: can be 1 or 
				2 -->
			<int name="maxEdits">2</int>
			<!-- the minimum shared prefix when enumerating terms -->
			<int name="minPrefix">1</int>
			<!-- maximum number of inspections per result. -->
			<int name="maxInspections">5</int>
			<!-- minimum length of a query term to be considered for correction -->
			<int name="minQueryLength">3</int>
			<!-- maximum threshold of documents a query term can appear to be considered 
				for correction -->
			<float name="maxQueryFrequency">0.01</float>
			<!-- uncomment this to require suggestions to occur in 1% of the documents 
				<float name="thresholdTokenFrequency">.01</float> -->
		</lst>

		<!-- a spellchecker that can break or combine words. See "/spell" handler 
			below for usage -->
		<lst name="spellchecker">
			<str name="name">wordbreak</str>
			<str name="classname">solr.WordBreakSolrSpellChecker</str>
			<str name="field">texte_correction</str>
			<str name="combineWords">true</str>
			<str name="breakWords">true</str>
			<int name="maxChanges">10</int>
		</lst>
	</searchComponent>

	<!-- Term Vector Component http://wiki.apache.org/solr/TermVectorComponent -->
	<searchComponent name="tvComponent" class="solr.TermVectorComponent" />

	<searchComponent name="terms" class="solr.TermsComponent" />

	<requestHandler name="/terms" class="solr.SearchHandler"
		startup="lazy">
		<lst name="defaults">
			<bool name="terms">true</bool>
			<bool name="distrib">false</bool>
		</lst>
		<arr name="components">
			<str>terms</str>
		</arr>
	</requestHandler>

	<requestHandler name="/elevate" class="solr.SearchHandler"
		startup="lazy">
		<lst name="defaults">
			<str name="echoParams">explicit</str>
			<str name="df">texte</str>
		</lst>
		<arr name="last-components">
			<str>elevator</str>
		</arr>
	</requestHandler>

	<!-- Highlighting Component http://wiki.apache.org/solr/HighlightingParameters -->
	<searchComponent class="solr.HighlightComponent" name="highlight">
		<highlighting>
			<!-- Configure the standard fragmenter -->
			<!-- This could most likely be commented out in the "default" case -->
			<fragmenter name="gap" default="true"
				class="solr.highlight.GapFragmenter">
				<lst name="defaults">
					<int name="hl.fragsize">100</int>
				</lst>
			</fragmenter>

			<!-- A regular-expression-based fragmenter (for sentence extraction) -->
			<fragmenter name="regex" class="solr.highlight.RegexFragmenter">
				<lst name="defaults">
					<!-- slightly smaller fragsizes work better because of slop -->
					<int name="hl.fragsize">70</int>
					<!-- allow 50% slop on fragment sizes -->
					<float name="hl.regex.slop">0.5</float>
					<!-- a basic sentence pattern -->
					<str name="hl.regex.pattern">[-\w ,/\n\&quot;&apos;]{20,200}</str>
				</lst>
			</fragmenter>

			<!-- Configure the standard formatter -->
			<formatter name="html" default="true"
				class="solr.highlight.HtmlFormatter">
				<lst name="defaults">
					<str name="hl.simple.pre"><![CDATA[<em>]]></str>
					<str name="hl.simple.post"><![CDATA[</em>]]></str>
				</lst>
			</formatter>

			<!-- Configure the standard encoder -->
			<encoder name="html" class="solr.highlight.HtmlEncoder" />

			<!-- Configure the standard fragListBuilder -->
			<fragListBuilder name="simple"
				class="solr.highlight.SimpleFragListBuilder" />

			<!-- Configure the single fragListBuilder -->
			<fragListBuilder name="single"
				class="solr.highlight.SingleFragListBuilder" />

			<!-- Configure the weighted fragListBuilder -->
			<fragListBuilder name="weighted" default="true"
				class="solr.highlight.WeightedFragListBuilder" />

			<!-- default tag FragmentsBuilder -->
			<fragmentsBuilder name="default" default="true"
				class="solr.highlight.ScoreOrderFragmentsBuilder">
				<!-- <lst name="defaults"> <str name="hl.multiValuedSeparatorChar">/</str> 
					</lst> -->
			</fragmentsBuilder>

			<!-- multi-colored tag FragmentsBuilder -->
			<fragmentsBuilder name="colored"
				class="solr.highlight.ScoreOrderFragmentsBuilder">
				<lst name="defaults">
					<str name="hl.tag.pre"><![CDATA[
               <b style="background:yellow">,<b style="background:lawgreen">,
               <b style="background:aquamarine">,<b style="background:magenta">,
               <b style="background:palegreen">,<b style="background:coral">,
               <b style="background:wheat">,<b style="background:khaki">,
               <b style="background:lime">,<b style="background:deepskyblue">]]></str>
					<str name="hl.tag.post"><![CDATA[</b>]]></str>
				</lst>
			</fragmentsBuilder>

			<boundaryScanner name="default" default="true"
				class="solr.highlight.SimpleBoundaryScanner">
				<lst name="defaults">
					<str name="hl.bs.maxScan">10</str>
					<str name="hl.bs.chars">.,!? &#9;&#10;&#13;</str>
				</lst>
			</boundaryScanner>

			<boundaryScanner name="breakIterator"
				class="solr.highlight.BreakIteratorBoundaryScanner">
				<lst name="defaults">
					<!-- type should be one of CHARACTER, WORD(default), LINE and SENTENCE -->
					<str name="hl.bs.type">WORD</str>
					<!-- language and country are used when constructing Locale object. -->
					<!-- And the Locale object will be used when getting instance of BreakIterator -->
					<str name="hl.bs.language">en</str>
					<str name="hl.bs.country">US</str>
				</lst>
			</boundaryScanner>
		</highlighting>
	</searchComponent>


	<queryResponseWriter name="velocity"
		class="solr.VelocityResponseWriter" startup="lazy" />


	<queryResponseWriter name="xslt" class="solr.XSLTResponseWriter">
		<int name="xsltCacheLifetimeSeconds">5</int>
	</queryResponseWriter>

	
	<admin>
		<defaultQuery>*:*</defaultQuery>
	</admin>

</config>
